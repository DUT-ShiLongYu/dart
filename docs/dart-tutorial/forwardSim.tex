\section{Forward Simulation}
In this section, we will build and simulate a simple chain of rigid
bodies connected by ball joints. This example demonstrates how an
articulated rigid body system is represented using DART data
structures and how a simulation step is formulated using different
numerical integration methods. Because this is the first example, we
will examine the source code in more details.

\subsection{Skeleton data structures}
Let us begin with the main function, which only does two things:
loading a skeleton file and creating a window for UI and rendering. 

\ttfamily
\begin{lstlisting}[caption=Main.cpp]
int main(int argc, char* argv[])
{
  FileInfoSkel<SkeletonDynamics> model;
  model.loadFile(DART_DATA_PATH"/skel/Chain.skel", SKEL);

  MyWindow window((SkeletonDynamics*)model.getSkel());
  
  glutInit(&argc, argv);
  window.initWindow(640, 480, "Forward Simulation");
  glutMainLoop();

  return 0;
}
\end{lstlisting}
\rmfamily 

We first focus on the data structure of skeleton. A skeleton comprises
a set of body nodes connected by joints. We can directly load a
skeleton from a file or manually build a new skeleton in the
code. DART currently supports two formats of skeleton file: .vsk and
.skel. In this example, we load in a skeleton (Chain.skel) with 10
rigid links connected by ball joints.

In general, an app developer does not need to know the details of DART
library. However, a basic understanding of the following classes can
help one quickly grasp the data structures DART uses for building a
simulation app.

\begin{itemize}
\item{Skeleton.} A basic class that contains a list of body nodes, a
  list of joints, and a list of degrees of freedom. 
\item{SkeletonDynamics.} A derived class from \textbf{Skeleton
    Class}. It provides member functions to compute dynamic equations
  of the skeleton.
\item{BodyNode.} A basic class that provides member functions to evaluate
  transformation and first derivatives of transformation, to access
  physical and geometric parameters of the node, and to compute the
  linear and angular Jacobian matrices for the node.
\item{BodyNodeDynamics.} A derived class from \textbf{BodyNode
    Class}. It provides member functions to compute dynamic variables
  required in the equations of motion.
\end{itemize}

\subsection{A simple app with graphics and UI}
To create and visualize a basic simulation app, we integrate DART into
Glut framework. All the examples in this tutorial use Glut and OpenGL
libraries to handle user interface and rendering. However, DART does
not assume a particular UI or rendering package.

In the main function, we create a graphics application based on
\textbf{MyWindow Class} derived from \textbf{GlutWindow Class}, which
is a simple API to interface with Glut functions. Based on the
features of the app, the app developer has to implement appropriate
virtual functions of \textbf{MyWindow Class}. In most graphics apps
with keyboard user interaction, three basic virtual functions must be
implemented:

\ttfamily
\begin{lstlisting}[caption=MyWindow.h]
  virtual void draw();
  virtual void keyboard(unsigned char key, int x, int y);
  virtual void displayTimer(int _val);
\end{lstlisting}
\rmfamily 

After instantiating and initializing \textbf{MyWindow Class} in main
function, \textbf{glutMainLoop} is invoked and Glut callback functions
will start handling display updates, keyboard inputs, etc.

\subsection{Simulation}
\subsubsection{Initialization}
Besides graphics and UI capabilities, \textbf{MyWindows Class} is also
able to forward simulate a passive skeleton. Before the simulation
begins, we need to initialize simulation state and dynamic variables
by calling \textbf{initDyn()}:

\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
void MyWindow::initDyn()
{
  mDofs.resize(mModel->getNumDofs());
  mDofVels.resize(mModel->getNumDofs());
  for(unsigned int i = 0; i < mModel->getNumDofs(); i++){
    mDofs[i] = random(-0.5, 0.5);
    mDofVels[i] = random(-0.1, 0.1);
  }
  mModel->initDynamics();
  mModel->setPose(mDofs, false, false);
}
\end{lstlisting}
\rmfamily 

\textbf{mDofs} and \textbf{mDofVels} together store the current value
of the simulation state. In this example, the simulation state
includes the joint position and velocity of the skeleton. In
\textbf{initDyn()}, we initialize \textbf{mDofs} and \textbf{mDofVels}
randomly to give the skeleton a random initial pose and joint
velocity. Because this app will access dynamic variables for
simulation, we also need to call the member function
\textbf{initDynamics()} of the \textbf{SkeletonDynamics
  Class}. Finally, we set the current pose of the skeleton to
\textbf{mDofs}. The two flags in \textbf{setPose()} will be explained
in details later.

\subsubsection{Simulation step}
The simulation code is called from the callback function
\textbf{displayTimer()} in MyWindow.cpp.

\ttfamily
\begin{lstlisting}[caption=MyWindows.cpp]
void MyWindow::displayTimer(int _val)
{
  int numIter = mDisplayTimeout / (1000 * mTimeStep);
  for (int i = 0; i < numIter; i++) {
    mIntegrator.integrate(this, mTimeStep);
    mFrame++;
  }
  glutPostRedisplay();
  if (mRunning)	
    glutTimerFunc(mDisplayTimeout, refreshTimer, _val);
}
\end{lstlisting}
\rmfamily Each time \textbf{integrate()} is called, DART simulates one
time step forward. The simulation time step is defined by
\textbf{mTimeStep}. \textbf{displayTimer()} is called every
\textbf{mDsiplayTimeout} millisecond. Because \textbf{mDsiplayTimeout}
is typically larger than \textbf{mTimeStep}, we need to run a few
iterations of simulation steps each time \textbf{displayTimer()} is
called. The number of iterations is computed as
\textbf{numIter}. Typically, a simulation step requires a few
procedures in the following order:

\framebox{\parbox{9cm}{
\begin{itemize}
\item Compute internal forces
\item Compute external forces
\item Integrate one step forward
\end{itemize}
}}

Since we do not have internal or external forces applied to the
skeleton in this example, invoking \textbf{integrate()} is the only
procedure required to simulate. We will see examples in later sections
that apply internal or external forces to the simulation.

\subsubsection{Integration}
\textbf{mIntegrator} is a data member of \textbf{MyWindows} and can be
declared as an explicit Euler integrator or a RK4 integrator in
MyWindows.h. Both integrators are derived from \textbf{Integrator
  Class}. Although each integration method has its own formula to
integrate the differential equation, the all explicit integration
methods can be constructed using three basic operations: \textbf{Get
  State}, \textbf{Set State}, and \textbf{Evaluate Derivatives}. These
three operations needed to be implemented by the app developer as
three virtual functions of \textbf{Integrator Class}:

\ttfamily
\begin{lstlisting}[caption=MyWindow.h]
  virtual Eigen::VectorXd getState();
  virtual void setState(Eigen::VectorXd state);	
  virtual Eigen::VectorXd evalDeriv();
\end{lstlisting}
\rmfamily 

\textbf{getState()} and \textbf{setState()} retrieve and
assign the value of current simulation state. The most involved
function to implement is \textbf{evalDeriv}, which computes the
derivative of the current state via equations of motion.

\ttfamily
\begin{lstlisting}[caption=MyWindows.cpp]
VectorXd MyWindow::evalDeriv() {
  mModel->setPose(mDofs, false, false);
  mModel->computeDynamics(mGravity, mDofVels, true);
  VectorXd deriv(mDofs.size() + mDofVels.size());
  VectorXd qddot = mModel->getInvMassMatrix() 
        * (-mModel->getCombinedVector());
  mModel->clampRotation(mDofs, mDofVels);
  deriv.head(mDofs.size()) = mDofVels + mTimeStep * qddot;
  deriv.tail(mDofVels.size()) = qddot;
  return deriv;
}
\end{lstlisting}
\rmfamily
In \textbf{evalDeriv}, we first call \textbf{setPose()} to update the
DOF values in the skeleton. \textbf{setPose()} takes in two boolean
flags. The first flag indicates whether to update all the
transformation matrices and the second flag indicates whether to
update first derivatives of the transformation matrices. Here we set
both of them to be false because the next function, 
\textbf{computeDynamics()}, will take care of the update of
transformation matrices and we do not need the information about first
derivatives in this app. As a rule of thumb, setting both flags to
true is the safest option, as it will provide the most complete
information at the cost of computation time.

\textbf{computeDynamics()} updates the mass matrix (and its
inversion), Coriolis and centrifugal force, generalized gravitational force,
and generalized external force based on the current DOFs and DOF
velocity. This is the most important function in DART, and obviously,
the most computational costly one. To speed up the computation time,
DART provides an alternative way to compute Coriolis, centrifugal, and
gravitational force using recursive inverse dynamics (See
\cite{dynamics-tutorial} for details). If the flag in
\textbf{computeDynamics()} is true, DART will utilize recursive
inverse dynamics formula to speed up the computation.

Once the terms in equations of motion are updated, the acceleration of
DOF (\textbf{qddot}) can be readily computed via Lagrange's equations:
\begin{equation}
M \ddot{\vc{q}} + C(\vc{q}, \dot{\vc{q}}) + G(\vc{q}) = \vc{0}
\end{equation}
Note that \textbf{getCombinedVector()} returns the sum of Coriolis,
centrifugal, and gravitational force, instead of each individual
force. Please refer \cite{dynamic-tutorial} for derivation of
Lagrange's equations.

\textbf{clampRotation()} is particularly important when a joint is
represented as an exponential map rotation. The system will become
unstable if the exponential map rotation is outside the range of
2PI. Once the rotation magnitude is changed, the velocity needs to
change accordingly to represent the same angular velocity.

\subsection{Damping force}
We encourage the reader to modify the example code with different time
steps and integration methods. RK1 is clearly faster than RK4, but the
simulation is unstable and bound to blow up after a few second. RK4 is
more stable, but its stability is still conditional on the time step
of the simulation. One way to create a more stable passive simulation
is to introduce damping force at joints. Damping forces can be added
as internal forces via member function \textbf{setInternalForces()} in
\textbf{Skeleton} class. 

\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
void MyWindow::displayTimer(int _val)
{
  .....
  for (int i = 0; i < numIter; i++) {
    VectorXd damping = computeDamping();
    mModel->setInternalForces(damping);
    mIntegrator.integrate(this, mTimeStep);
    mFrame++;
  }
  .....
}
\end{lstlisting}
\rmfamily

The internal forces also need to be included when evaluating the
derivatives for integration:

\ttfamily
\begin{lstlisting}[caption=MyWindows.cpp]
VectorXd MyWindow::evalDeriv() {
  .....
  VectorXd qddot = mModel->getInvMassMatrix() 
        * (-mModel->getCombinedVector()
        + mModel->getInternalForces());
  .....
}
\end{lstlisting}
\rmfamily

Computing appropriate damping force requires some tweaking because the
explicit integration methods are only conditionally stable. We set the
damping coefficient to $0.001$ for all the DOFs controlling twisting
and $0.01$ for the rest of DOFs.

\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
VectorXd MyWindow::computeDamping()
{
  VectorXd damping = VectorXd::Zero(mDofVels.size());
  damping = -0.01 * mDofVels;
  for (int i = 0; i < damping.size(); i++)
  if (i % 3 == 1)
    damping[i] *= 0.1;
  return damping;
}
\end{lstlisting}
\rmfamily
