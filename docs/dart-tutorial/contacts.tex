\section{Contacts}
This section introduces the collision detection and handling in DART. We
will simulate three boxes and the ground and visualize their motion
due to collisions. We follow the same Glut framework described in the
previous section, but in this example we allow the user to apply
forces to interact one of the boxes. We also add playback
functionality so the user can replay the simulation result.

\subsection{Contact dynamics}
Collision detection and handling are implemented in
\textbf{ContactDynamics Class}. To include collision functionality in
the application, the user needs to create an instance of
\textbf{ContactDynamics}. The constructor of \textbf{ContactDynamics
  Class} requires the user to pass in a list of skeletons potentially
participating collision, the simulation time step, friction
coefficient (\_mu), and the number of friction cone basis vectors
(\_d). The default values for \_mu and \_d are 1.0 and 4. In general, a
smaller \_mu indicates a more slippery the colliding surface, and a
larger \_d results in more accurate the sliding contact. Please see
\cite{LCP-tutorial} for detailed implementation of LCP contact
modeling.

Applying collision detection and handling is very straightforward in
DART once \textbf{ContactDynamics} is instantiated. The user can call
the member function, \textbf{applyContactForces()}, every time
collision and contact forces need to be updated. The resulting contact
forces are represented in two different
ways. \textbf{getConstraintForce()} returns the contact forces in
generalized coordinates of a desired skeleton. Alternatively, the user
can retrieve the contact forces in the Cartesian space by accessing
the data structure of each contact point via
\textbf{getCollisionChecker()}. We will see examples of both cases in
the next subsection.

\subsection{Simulation}

\subsubsection{Initialization}
\textbf{initDyn()} for this example is very similar to the one
described in Section \ref{}: we initialize the simulation state variables, \textbf{mDofs} and
\textbf{mDofVels}, and then initialize the dynamic variables and the
pose of the skeleton. The differences in this example are the following.
\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
void MyWindow::initDyn()
{
  .....
  mSkels[0]->setImmobileState(true);
  mCollisionHandle = new dynamics::ContactDynamics(mSkels, 
      mTimeStep);
}
\end{lstlisting}
\rmfamily First, we set the ``ground'' skeleton to be immobile. If a
skeleton is immobile, it is not included in the dynamic simulation,
namely, it cannot be moved by forces. However, it still participates
in collision detection and will induce contact forces to other
skeletons. Second, we create an instance of \textbf{ContactDynamics
  Class}, \textbf{mCollisionHandle}, to handle collisions between all the
skeletons in the scene, including a ground and three boxes.

\subsubsection{Simulation step}
Again, simulation code is invoked from the callback function
\textbf{displayTimer()}. In this example, we add a new feature of
playback, which bakes and replays the simulation results.

\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
void MyWindow::displayTimer(int _val)
{
  int numIter = mDisplayTimeout / (mTimeStep * 1000);
  if (mPlay) {
    mPlayFrame += 16;
    if (mPlayFrame >= mBakedStates.size())
      mPlayFrame = 0;
 }else if (mSim) {
    for (int i = 0; i < numIter; i++) {
      static_cast<BodyNodeDynamics*>(mSkels[1]->getNode(0))
          ->addExtForce(Vector3d(0.0, 0.0, 0.0), mForce);
      mIntegrator.integrate(this, mTimeStep);
      bake();
      mSimFrame++;
    }
    mForce.setZero();
  }
  glutPostRedisplay();
  glutTimerFunc(mDisplayTimeout, refreshTimer, _val);
}
\end{lstlisting}
\rmfamily When the flag \textbf{mPlay} is true, playback mode is
active and the frame index \textbf{mPlayFrame} is incrementing based
on the desired playback speed ($16$ is arbitrarily chosen). If
\textbf{mSim} is true, DART enters the simulation mode and runs
\textbf{numIter} steps of simulation as described in Section
\ref{}. The difference in this example is that the user can push the
largest box on the ground and DART will take into account this
external force in the simulation. \textbf{addExtForce()} is a member
function of \textbf{BodyNodeDynamics Class}. It takes input arguments
as the coordinates of the point of application in the body frame, as
well as the force vector in the world frame. \textbf{addExtForce()}
also provides the options to express the point of application in the
world frame or the force vector in the body frame.

\ttfamily
\begin{lstlisting}[caption=BodyNodeDynamics.h]
void addExtForce( const Eigen::Vector3d& _offset, 
                             const Eigen::Vector3d& _force, 
                             bool _isOffsetLocal=true, 
                             bool _isForceLocal=false );
\end{lstlisting}
\rmfamily

After each integration step, we call \textbf{bake()} to store the new
states of the skeletons and the collision results. The information of
collision is stored in the data structure \textbf{ContactPoint}.
\ttfamily
\begin{lstlisting}[caption=CollisionSkeleton.h]
struct ContactPoint {
  Eigen::Vector3d point;
  Eigen::Vector3d normal;
  Eigen::Vector3d force;
  .....
}
\end{lstlisting}
\rmfamily

The developer can access the position, normal, and Cartesian force of any
contact point via the member data, \textbf{mCollisionChecker} in
\textbf{ContactDynamics Class}.  

\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
void MyWindow::bake()
{
  .....
  for (int i = 0; i < nContact; i++) {
    int begin = mIndices.back() + i * 6;
    state.segment(begin, 3) = mCollisionHandle
      ->getCollisionChecker()->getContact(i).point;
    state.segment(begin + 3, 3) = mCollisionHandle
      ->getCollisionChecker()->getContact(i).force;
  }
  .....
}
\end{lstlisting}
\rmfamily

\subsubsection{Integration}
The integration process is very similar to the previous example where
\textbf{evalDeriv()} updates the degrees of freedom in skeletons
according to the current simulation state, evaluates the dynamic
variables of equations of motion, and finally computes the derivatives
for integration.

\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
VectorXd MyWindow::evalDeriv() {
  for (unsigned int i = 0; i < mSkels.size(); i++) {
    if (mSkels[i]->getImmobileState()) {
      mSkels[i]->setPose(mDofs[i], true, false);
    } else {
      mSkels[i]->setPose(mDofs[i], false, true);
      mSkels[i]->computeDynamics(mGravity, mDofVels[i], true);
    }
  }
  mCollisionHandle->applyContactForces();

  VectorXd deriv = VectorXd::Zero(mIndices.back() * 2);    
  for (unsigned int i = 0; i < mSkels.size(); i++) {
    if (mSkels[i]->getImmobileState())
      continue;
    int start = mIndices[i] * 2;
    int size = mDofs[i].size();
    VectorXd qddot = mSkels[i]->getInvMassMatrix() 
        * (-mSkels[i]->getCombinedVector() 
        + mSkels[i]->getExternalForces() 
        + mCollisionHandle->getConstraintForce(i));
    mSkels[i]->clampRotation(mDofs[i], mDofVels[i]);
    deriv.segment(start, size) = mDofVels[i] + (qddot * mTimeStep);
    deriv.segment(start + size, size) = qddot;
  }
  return deriv;
}
\end{lstlisting}
\rmfamily

If a skeleton is immobile, we do not need to evaluate
its dynamic equations, but we still need to call \textbf{setPose()} to
update its degrees of freedom for collision detection. Note that the
first flag is set to true because the updated transformation matrices
are required in collision detection routine. For a mobile skeleton, we
call both \textbf{setPose()} and \textbf{computeDynamics()}. Similar
to the previos example, the first flag in \textbf{setPose()} is
false. However, the second flag must be true for this example because
the updated derivative information is needed in collision handling
routine.

Because this app involves collision, we need to invoke
\textbf{applyContactForces()} in \textbf{evalDeriv()}. The collision
detection and handling routine compute appropriate contact forces and
store them in generalized coordinates. When computing the derivatives
\textbf{qddot}, we need to include the contact forces by calling
\textbf{getConstraintForce()}. In this example, we also allow for
external push forces as user input. Therefore,
\textbf{getExternalForces()} is called when computing \textbf{qddot}.
