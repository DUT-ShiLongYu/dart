\section{Proportional-Derivative Control}
So far we have only applied DART to simulate passive skeletons. In
this section, we will develop a simple proportional-derivative (PD)
controller for a hand skeleton. The goal of this controller is to
compute the torques required to track an input trajectory of the hand
against gravity and external push forces. Later in this section, we
will modify the standard PD controller to a different formulation,
called stable proportional-derivative (SPD) control.

\subsection{Controller}
We create a \textbf{Controller Class} to compute joint torques at each
simulation time step. The constructor takes as input a reference
motion, a skeleton, and the simulation time step. 
\ttfamily
\begin{lstlisting}[caption=Controller.cpp]
Controller::Controller(kinematics::FileInfoDof *_motion, 
  dynamics::SkeletonDynamics *_skel, double _t) {
  mMotion = _motion;
  mSkel = _skel;
  mTimestep = _t;
  int nDof = mSkel->getNumDofs();
  mKp = MatrixXd::Identity(nDof, nDof);
  mKd = MatrixXd::Identity(nDof, nDof);;
  
  mTorques.resize(nDof);
  mDesiredDofs.resize(nDof);
  for (int i = 0; i < nDof; i++){
    mTorques[i] = 0.0;
    mDesiredDofs[i] = mSkel->getDof(i)->getValue();
  }

  for (int i = 0; i < nDof; i++) {
    mKp(i, i) = 800.0;
    mKd(i, i) = 15;
  }

  mSimFrame = 0;
  mInterval = (1.0 / mMotion->getFPS()) / mTimestep;
}
\end{lstlisting}
\rmfamily 

For each DOF, we need to determine the stiffness \textbf{mKp} and the
damping \textbf{mKd} parameters. The values of these parameters
directly affect the stability of the simulation, but tweaking them by
hand is not a trivial task. Many factors, such as mass distribution,
skeleton configuration, and joint types, need to be considered in the
parameter tuning process. In this example, we are able to select one
single value for the entire set of DOFs because we can take advantage
of the mass matrix information computed by DART (detailed
later). Finally, we need to account for the difference in a simulation
time step and input motion frame rate. \textbf{mInterval} stores the
number of simulation time steps for each frame of the input motion.

Given the current DOF and DOF velocity, \textbf{computeTorques()}
updates the desired DOFs (\textbf{mDesiredDofs} and computes the
generalized torques (\textbf{mTorques}). We scale \textbf{mTorques} by
the current mass matrix so that the final torques accounts for the
accumulated mass and inertial controlled by each DOF.

\ttfamily
\begin{lstlisting}[caption=Controller.cpp]
void Controller::computeTorques(const VectorXd& _dof, 
  const VectorXd& _dofVel) {
  int motionFrame = mSimFrame / mInterval;    
  if (motionFrame >= mMotion->getNumFrames())
    motionFrame = mMotion->getNumFrames() - 1;
  
  mDesiredDofs = mMotion->getPoseAtFrame(motionFrame);
  mTorques = -mKp * (_dof - mDesiredDofs) - mKd * _dofVel;
  mTorques = mSkel->getMassMatrix() * mTorques;
  mSimFrame++;
}
\end{lstlisting}
\rmfamily

\subsection{Simulation}

\subsubsection{Initialization}
The initialization code is very similar to previous examples. One
thing different in this example is that \textbf{initDyn()} needs to
call \textbf{computeDynamics()} from the skeleton. This is because the
computation of control force at first simulation step needs to access
mass matrix (recall that we scale \textbf{mTorques} by the mass
matrix). Another difference here is that we need to instantiate
\textbf{Controller Class} and assign the current pose to
\textbf{mDesiredDofs} for the controller.
 
\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
void MyWindow::initDyn()
{
  .....

  for (unsigned int i = 0; i < mSkels.size(); i++) {
    mSkels[i]->initDynamics();
    mSkels[i]->setPose(mDofs[i], false, false);
    mSkels[i]->computeDynamics(mGravity, mDofVels[i], false);
  }
  
  int nDof = mSkels[0]->getNumDofs();
  mController = new Controller(mMotion, mSkels[0], mTimeStep);
  for (int i = 0; i < nDof; i++)
    mController->setDesiredDof(i, mController->getSkel()
      ->getDof(i)->getValue());
}
\end{lstlisting}
\rmfamily

\subsubsection{Simulation Step}
At each simulation step, we need to collect the external push force,
compute internal control force, and integrate to the next step. In
this example, we allow the user to use keyboard to push the distal
segment of index finger.

\ttfamily
\begin{lstlisting}[caption=MyWindow.cpp]
void MyWindow::displayTimer(int _val)
{
  .....
  static_cast<BodyNodeDynamics*>(mSkels[0]
    ->getNode("fixedHand_indexDIP"))
    ->addExtForce(Vector3d(0.02, 0.0, 0), mForce);
  mController->computeTorques(mDofs[0], mDofVels[0]);
  mSkels[0]->setInternalForces(mController->getTorques());
  mIntegrator.integrate(this, mTimeStep);
  .....
}
\end{lstlisting}
\rmfamily

\subsection{Stable PD Control}
Using the current mass matrix to scale the control forces greatly
reduces the need to tuen stiffness and damping parameters for the PD
controllers. However, we implement another control method that
produces even more robust tracking results. This controller, termed
SPD, was introduced by Tan \etal \cite{}. Please refer to the paper
for formulation details.

The range of stiffness and damping parameters that produce stable
results is a lot wider than standard PD controllers. Here we arbitrary
pick two values and assign them for all DOFs.

\ttfamily
\begin{lstlisting}[caption=Controller.cpp]
Controller::Controller(kinematics::FileInfoDof *_motion, 
  dynamics::SkeletonDynamics *_skel, double _t) {
  .....
#ifdef SPD
  for (int i = 0; i < nDof; i++) {
    mKp(i, i) = 15.0;
    mKd(i, i) = 2.0;
  }
#else
  for (int i = 0; i < nDof; i++) {
    mKp(i, i) = 800.0;
    mKd(i, i) = 15;
  }
#endif
  .....
}
\end{lstlisting}
\rmfamily

We simply follow the formulation in \cite{} to compute control force
at each simulation step. 
\begin{equation}
\ddot{\vc{q}}^n = (M + K_d \Delta t)^{-1} (-C - K_p(\vc{q}^n +
\dot{\vc{q}}^n \Delta t - \bar{\vc{q}}^{n+1}) - K_d \dot{\vc{q}}^n +
\tau_{ext} + \tau_{int})
\end{equation}
where $\bar{\vc{q}}^{n+1}$ is the reference pose in the next time step.

\ttfamily
\begin{lstlisting}[caption=Controller.cpp]
void Controller::computeTorques(const VectorXd& _dof,
  const VectorXd& _dofVel) {
  .....
#ifdef SPD
  MatrixXd invM = (mSkel->getMassMatrix() + mKd * mTimestep)
    .inverse();
  VectorXd p = -mKp * (_dof + _dofVel * mTimestep - mDesiredDofs);
  VectorXd d = -mKd * _dofVel;
  VectorXd qddot = invM * (-mSkel->getCombinedVector() + p + d);
  mTorques = p + d - mKd * qddot * mTimestep;
#else
  mTorques = -mKp * (_dof - mDesiredDofs) - mKd * _dofVel;
  mTorques = mSkel->getMassMatrix() * mTorques;
#endif
  .....
}
\end{lstlisting}
\rmfamily

Note that the computation of SPD is more costly due to the inversion
of augmented mass matrix. The developer should weigh in stability,
performance, and development effort when choose between using PD or
SPD.
